"use strict";(self.webpackChunkPersonalWebsite=self.webpackChunkPersonalWebsite||[]).push([[461],{50:(we,Se,Ne)=>{Ne(935),Ne(542)},542:()=>{const $e=globalThis;function xe(C){return($e.__Zone_symbol_prefix||"__zone_symbol__")+C}const Je=typeof window<"u"&&window||typeof self<"u"&&self||global;class Ge{static get symbolParentUnresolved(){return xe("parentUnresolved")}constructor(e,n,c){this.finishCallback=e,this.failCallback=n,this._pendingMicroTasks=!1,this._pendingMacroTasks=!1,this._alreadyErrored=!1,this._isSync=!1,this._existingFinishTimer=null,this.entryFunction=null,this.runZone=Zone.current,this.unresolvedChainedPromiseCount=0,this.supportWaitUnresolvedChainedPromise=!1,this.name="asyncTestZone for "+c,this.properties={AsyncTestZoneSpec:this},this.supportWaitUnresolvedChainedPromise=!0===Je[xe("supportWaitUnResolvedChainedPromise")]}isUnresolvedChainedPromisePending(){return this.unresolvedChainedPromiseCount>0}_finishCallbackIfDone(){null!==this._existingFinishTimer&&(clearTimeout(this._existingFinishTimer),this._existingFinishTimer=null),this._pendingMicroTasks||this._pendingMacroTasks||this.supportWaitUnresolvedChainedPromise&&this.isUnresolvedChainedPromisePending()||this.runZone.run(()=>{this._existingFinishTimer=setTimeout(()=>{!this._alreadyErrored&&!this._pendingMicroTasks&&!this._pendingMacroTasks&&this.finishCallback()},0)})}patchPromiseForTest(){if(!this.supportWaitUnresolvedChainedPromise)return;const e=Promise[Zone.__symbol__("patchPromiseForTest")];e&&e()}unPatchPromiseForTest(){if(!this.supportWaitUnresolvedChainedPromise)return;const e=Promise[Zone.__symbol__("unPatchPromiseForTest")];e&&e()}onScheduleTask(e,n,c,r){return"eventTask"!==r.type&&(this._isSync=!1),"microTask"===r.type&&r.data&&r.data instanceof Promise&&!0===r.data[Ge.symbolParentUnresolved]&&this.unresolvedChainedPromiseCount--,e.scheduleTask(c,r)}onInvokeTask(e,n,c,r,P,E){return"eventTask"!==r.type&&(this._isSync=!1),e.invokeTask(c,r,P,E)}onCancelTask(e,n,c,r){return"eventTask"!==r.type&&(this._isSync=!1),e.cancelTask(c,r)}onInvoke(e,n,c,r,P,E,R){this.entryFunction||(this.entryFunction=r);try{return this._isSync=!0,e.invoke(c,r,P,E,R)}finally{this._isSync&&this.entryFunction===r&&this._finishCallbackIfDone()}}onHandleError(e,n,c,r){return e.handleError(c,r)&&(this.failCallback(r),this._alreadyErrored=!0),!1}onHasTask(e,n,c,r){e.hasTask(c,r),n===c&&("microTask"==r.change?(this._pendingMicroTasks=r.microTask,this._finishCallbackIfDone()):"macroTask"==r.change&&(this._pendingMacroTasks=r.macroTask,this._finishCallbackIfDone()))}}const ce="object"==typeof window&&window||"object"==typeof self&&self||globalThis.global,Oe=ce.Date;function Me(){if(0===arguments.length){const C=new Oe;return C.setTime(Me.now()),C}{const C=Array.prototype.slice.call(arguments);return new Oe(...C)}}let De;Me.now=function(){const C=Zone.current.get("FakeAsyncTestZoneSpec");return C?C.getFakeSystemTime():Oe.now.apply(this,arguments)},Me.UTC=Oe.UTC,Me.parse=Oe.parse;const ot=function(){};let Ae=(()=>{class C{static{this.nextNodeJSId=1}static{this.nextId=-1}constructor(){this._schedulerQueue=[],this._currentTickTime=0,this._currentFakeBaseSystemTime=Oe.now(),this._currentTickRequeuePeriodicEntries=[]}static getNextId(){const n=De.nativeSetTimeout.call(ce,ot,0);return De.nativeClearTimeout.call(ce,n),"number"==typeof n?n:C.nextNodeJSId++}getCurrentTickTime(){return this._currentTickTime}getFakeSystemTime(){return this._currentFakeBaseSystemTime+this._currentTickTime}setFakeBaseSystemTime(n){this._currentFakeBaseSystemTime=n}getRealSystemTime(){return Oe.now()}scheduleFunction(n,c,r){let P=(r={args:[],isPeriodic:!1,isRequestAnimationFrame:!1,id:-1,isRequeuePeriodic:!1,...r}).id<0?C.nextId:r.id;C.nextId=C.getNextId();let R={endTime:this._currentTickTime+c,id:P,func:n,args:r.args,delay:c,isPeriodic:r.isPeriodic,isRequestAnimationFrame:r.isRequestAnimationFrame};r.isRequeuePeriodic&&this._currentTickRequeuePeriodicEntries.push(R);let g=0;for(;g<this._schedulerQueue.length&&!(R.endTime<this._schedulerQueue[g].endTime);g++);return this._schedulerQueue.splice(g,0,R),P}removeScheduledFunctionWithId(n){for(let c=0;c<this._schedulerQueue.length;c++)if(this._schedulerQueue[c].id==n){this._schedulerQueue.splice(c,1);break}}removeAll(){this._schedulerQueue=[]}getTimerCount(){return this._schedulerQueue.length}tickToNext(n=1,c,r){this._schedulerQueue.length<n||this.tick(this._schedulerQueue[n-1].endTime-this._currentTickTime,c,r)}tick(n=0,c,r){let P=this._currentTickTime+n,E=0;const R=(r=Object.assign({processNewMacroTasksSynchronously:!0},r)).processNewMacroTasksSynchronously?this._schedulerQueue:this._schedulerQueue.slice();if(0===R.length&&c)c(n);else{for(;R.length>0&&(this._currentTickRequeuePeriodicEntries=[],!(P<R[0].endTime));){let te=R.shift();if(!r.processNewMacroTasksSynchronously){const ve=this._schedulerQueue.indexOf(te);ve>=0&&this._schedulerQueue.splice(ve,1)}if(E=this._currentTickTime,this._currentTickTime=te.endTime,c&&c(this._currentTickTime-E),!te.func.apply(ce,te.isRequestAnimationFrame?[this._currentTickTime]:te.args))break;r.processNewMacroTasksSynchronously||this._currentTickRequeuePeriodicEntries.forEach(ve=>{let ie=0;for(;ie<R.length&&!(ve.endTime<R[ie].endTime);ie++);R.splice(ie,0,ve)})}E=this._currentTickTime,this._currentTickTime=P,c&&c(this._currentTickTime-E)}}flushOnlyPendingTimers(n){if(0===this._schedulerQueue.length)return 0;const c=this._currentTickTime;return this.tick(this._schedulerQueue[this._schedulerQueue.length-1].endTime-c,n,{processNewMacroTasksSynchronously:!1}),this._currentTickTime-c}flush(n=20,c=!1,r){return c?this.flushPeriodic(r):this.flushNonPeriodic(n,r)}flushPeriodic(n){if(0===this._schedulerQueue.length)return 0;const c=this._currentTickTime;return this.tick(this._schedulerQueue[this._schedulerQueue.length-1].endTime-c,n),this._currentTickTime-c}flushNonPeriodic(n,c){const r=this._currentTickTime;let P=0,E=0;for(;this._schedulerQueue.length>0;){if(E++,E>n)throw new Error("flush failed after reaching the limit of "+n+" tasks. Does your code use a polling timeout?");if(0===this._schedulerQueue.filter(te=>!te.isPeriodic&&!te.isRequestAnimationFrame).length)break;const R=this._schedulerQueue.shift();if(P=this._currentTickTime,this._currentTickTime=R.endTime,c&&c(this._currentTickTime-P),!R.func.apply(ce,R.args))break}return this._currentTickTime-r}}return C})();class le{static assertInZone(){if(null==Zone.current.get("FakeAsyncTestZoneSpec"))throw new Error("The code should be running in the fakeAsync zone to call this function")}constructor(e,n=!1,c){this.trackPendingRequestAnimationFrame=n,this.macroTaskOptions=c,this._scheduler=new Ae,this._microtasks=[],this._lastError=null,this._uncaughtPromiseErrors=Promise[Zone.__symbol__("uncaughtPromiseErrors")],this.pendingPeriodicTimers=[],this.pendingTimers=[],this.patchDateLocked=!1,this.properties={FakeAsyncTestZoneSpec:this},this.name="fakeAsyncTestZone for "+e,this.macroTaskOptions||(this.macroTaskOptions=ce[Zone.__symbol__("FakeAsyncTestMacroTask")])}_fnAndFlush(e,n){return(...c)=>(e.apply(ce,c),null===this._lastError?(null!=n.onSuccess&&n.onSuccess.apply(ce),this.flushMicrotasks()):null!=n.onError&&n.onError.apply(ce),null===this._lastError)}static _removeTimer(e,n){let c=e.indexOf(n);c>-1&&e.splice(c,1)}_dequeueTimer(e){return()=>{le._removeTimer(this.pendingTimers,e)}}_requeuePeriodicTimer(e,n,c,r){return()=>{-1!==this.pendingPeriodicTimers.indexOf(r)&&this._scheduler.scheduleFunction(e,n,{args:c,isPeriodic:!0,id:r,isRequeuePeriodic:!0})}}_dequeuePeriodicTimer(e){return()=>{le._removeTimer(this.pendingPeriodicTimers,e)}}_setTimeout(e,n,c,r=!0){let P=this._dequeueTimer(Ae.nextId),E=this._fnAndFlush(e,{onSuccess:P,onError:P}),R=this._scheduler.scheduleFunction(E,n,{args:c,isRequestAnimationFrame:!r});return r&&this.pendingTimers.push(R),R}_clearTimeout(e){le._removeTimer(this.pendingTimers,e),this._scheduler.removeScheduledFunctionWithId(e)}_setInterval(e,n,c){let r=Ae.nextId,P={onSuccess:null,onError:this._dequeuePeriodicTimer(r)},E=this._fnAndFlush(e,P);return P.onSuccess=this._requeuePeriodicTimer(E,n,c,r),this._scheduler.scheduleFunction(E,n,{args:c,isPeriodic:!0}),this.pendingPeriodicTimers.push(r),r}_clearInterval(e){le._removeTimer(this.pendingPeriodicTimers,e),this._scheduler.removeScheduledFunctionWithId(e)}_resetLastErrorAndThrow(){let e=this._lastError||this._uncaughtPromiseErrors[0];throw this._uncaughtPromiseErrors.length=0,this._lastError=null,e}getCurrentTickTime(){return this._scheduler.getCurrentTickTime()}getFakeSystemTime(){return this._scheduler.getFakeSystemTime()}setFakeBaseSystemTime(e){this._scheduler.setFakeBaseSystemTime(e)}getRealSystemTime(){return this._scheduler.getRealSystemTime()}static patchDate(){ce[Zone.__symbol__("disableDatePatching")]||ce.Date!==Me&&(ce.Date=Me,Me.prototype=Oe.prototype,le.checkTimerPatch())}static resetDate(){ce.Date===Me&&(ce.Date=Oe)}static checkTimerPatch(){if(!De)throw new Error("Expected timers to have been patched.");ce.setTimeout!==De.setTimeout&&(ce.setTimeout=De.setTimeout,ce.clearTimeout=De.clearTimeout),ce.setInterval!==De.setInterval&&(ce.setInterval=De.setInterval,ce.clearInterval=De.clearInterval)}lockDatePatch(){this.patchDateLocked=!0,le.patchDate()}unlockDatePatch(){this.patchDateLocked=!1,le.resetDate()}tickToNext(e=1,n,c={processNewMacroTasksSynchronously:!0}){e<=0||(le.assertInZone(),this.flushMicrotasks(),this._scheduler.tickToNext(e,n,c),null!==this._lastError&&this._resetLastErrorAndThrow())}tick(e=0,n,c={processNewMacroTasksSynchronously:!0}){le.assertInZone(),this.flushMicrotasks(),this._scheduler.tick(e,n,c),null!==this._lastError&&this._resetLastErrorAndThrow()}flushMicrotasks(){for(le.assertInZone();this._microtasks.length>0;){let n=this._microtasks.shift();n.func.apply(n.target,n.args)}(()=>{(null!==this._lastError||this._uncaughtPromiseErrors.length)&&this._resetLastErrorAndThrow()})()}flush(e,n,c){le.assertInZone(),this.flushMicrotasks();const r=this._scheduler.flush(e,n,c);return null!==this._lastError&&this._resetLastErrorAndThrow(),r}flushOnlyPendingTimers(e){le.assertInZone(),this.flushMicrotasks();const n=this._scheduler.flushOnlyPendingTimers(e);return null!==this._lastError&&this._resetLastErrorAndThrow(),n}removeAllTimers(){le.assertInZone(),this._scheduler.removeAll(),this.pendingPeriodicTimers=[],this.pendingTimers=[]}getTimerCount(){return this._scheduler.getTimerCount()+this._microtasks.length}onScheduleTask(e,n,c,r){switch(r.type){case"microTask":let E,P=r.data&&r.data.args;if(P){let R=r.data.cbIdx;"number"==typeof P.length&&P.length>R+1&&(E=Array.prototype.slice.call(P,R+1))}this._microtasks.push({func:r.invoke,args:E,target:r.data&&r.data.target});break;case"macroTask":switch(r.source){case"setTimeout":r.data.handleId=this._setTimeout(r.invoke,r.data.delay,Array.prototype.slice.call(r.data.args,2));break;case"setImmediate":r.data.handleId=this._setTimeout(r.invoke,0,Array.prototype.slice.call(r.data.args,1));break;case"setInterval":r.data.handleId=this._setInterval(r.invoke,r.data.delay,Array.prototype.slice.call(r.data.args,2));break;case"XMLHttpRequest.send":throw new Error("Cannot make XHRs from within a fake async test. Request URL: "+r.data.url);case"requestAnimationFrame":case"webkitRequestAnimationFrame":case"mozRequestAnimationFrame":r.data.handleId=this._setTimeout(r.invoke,16,r.data.args,this.trackPendingRequestAnimationFrame);break;default:const R=this.findMacroTaskOption(r);if(R){const g=r.data&&r.data.args,te=g&&g.length>1?g[1]:0;let se=R.callbackArgs?R.callbackArgs:g;R.isPeriodic?(r.data.handleId=this._setInterval(r.invoke,te,se),r.data.isPeriodic=!0):r.data.handleId=this._setTimeout(r.invoke,te,se);break}throw new Error("Unknown macroTask scheduled in fake async test: "+r.source)}break;case"eventTask":r=e.scheduleTask(c,r)}return r}onCancelTask(e,n,c,r){switch(r.source){case"setTimeout":case"requestAnimationFrame":case"webkitRequestAnimationFrame":case"mozRequestAnimationFrame":return this._clearTimeout(r.data.handleId);case"setInterval":return this._clearInterval(r.data.handleId);default:const P=this.findMacroTaskOption(r);if(P){const E=r.data.handleId;return P.isPeriodic?this._clearInterval(E):this._clearTimeout(E)}return e.cancelTask(c,r)}}onInvoke(e,n,c,r,P,E,R){try{return le.patchDate(),e.invoke(c,r,P,E,R)}finally{this.patchDateLocked||le.resetDate()}}findMacroTaskOption(e){if(!this.macroTaskOptions)return null;for(let n=0;n<this.macroTaskOptions.length;n++){const c=this.macroTaskOptions[n];if(c.source===e.source)return c}return null}onHandleError(e,n,c,r){return this._lastError=r,!1}}let pe=null;function Ke(){return Zone&&Zone.ProxyZoneSpec}function Ye(){pe&&pe.unlockDatePatch(),pe=null,Ke()&&Ke().assertPresent().resetDelegate()}function re(C,e={}){const{flush:n=!1}=e,c=function(...r){const P=Ke();if(!P)throw new Error("ProxyZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/proxy");const E=P.assertPresent();if(Zone.current.get("FakeAsyncTestZoneSpec"))throw new Error("fakeAsync() calls can not be nested");try{if(!pe){const te=Zone&&Zone.FakeAsyncTestZoneSpec;if(E.getDelegate()instanceof te)throw new Error("fakeAsync() calls can not be nested");pe=new te}let R;const g=E.getDelegate();E.setDelegate(pe),pe.lockDatePatch();try{R=C.apply(this,r),n?pe.flush(20,!0):et()}finally{E.setDelegate(g)}if(!n){if(pe.pendingPeriodicTimers.length>0)throw new Error(`${pe.pendingPeriodicTimers.length} periodic timer(s) still in the queue.`);if(pe.pendingTimers.length>0)throw new Error(`${pe.pendingTimers.length} timer(s) still in the queue.`)}return R}finally{Ye()}};return c.isFakeAsync=!0,c}function He(){if(null==pe&&(pe=Zone.current.get("FakeAsyncTestZoneSpec"),null==pe))throw new Error("The code should be running in the fakeAsync zone to call this function");return pe}function Ve(C=0,e=!1){He().tick(C,null,e)}function ge(C){return He().flush(C)}function dt(){He().pendingPeriodicTimers.length=0}function et(){He().flushMicrotasks()}function ut(C){const e="\n",n={},c="__creationTrace__",r="STACKTRACE TRACKING",P="__SEP_TAG__";let E=P+"@[native]";class R{constructor(){this.error=ie(),this.timestamp=new Date}}function g(){return new Error(r)}function te(){try{throw g()}catch(h){return h}}const se=g(),ve=te(),ie=se.stack?g:ve.stack?te:g;function Ee(h){return h.stack?h.stack.split(e):[]}function H(h,y){let v=Ee(y);for(let k=0;k<v.length;k++)n.hasOwnProperty(v[k])||h.push(v[k])}function S(h,y){const v=[y?y.trim():""];if(h){let k=(new Date).getTime();for(let J=0;J<h.length;J++){const me=h[J],Qe=me.timestamp;let qe=`____________________Elapsed ${k-Qe.getTime()} ms; At: ${Qe}`;qe=qe.replace(/[^\w\d]/g,"_"),v.push(E.replace(P,qe)),H(v,me.error),k=Qe.getTime()}}return v.join(e)}function V(){return Error.stackTraceLimit>0}function m(h,y){y>0&&(h.push(Ee((new R).error)),m(h,y-1))}C.longStackTraceZoneSpec={name:"long-stack-trace",longStackTraceLimit:10,getLongStackTrace:function(h){if(!h)return;const y=h[C.__symbol__("currentTaskTrace")];return y?S(y,h.stack):h.stack},onScheduleTask:function(h,y,v,k){if(V()){const J=C.currentTask;let me=J&&J.data&&J.data[c]||[];me=[new R].concat(me),me.length>this.longStackTraceLimit&&(me.length=this.longStackTraceLimit),k.data||(k.data={}),"eventTask"===k.type&&(k.data={...k.data}),k.data[c]=me}return h.scheduleTask(v,k)},onHandleError:function(h,y,v,k){if(V()){const J=C.currentTask||k.task;if(k instanceof Error&&J){const me=S(J.data&&J.data[c],k.stack);try{k.stack=k.longStack=me}catch{}}}return h.handleError(v,k)}},function b(){if(!V())return;const h=[];m(h,2);const y=h[0],v=h[1];for(let k=0;k<y.length;k++){const J=y[k];if(-1==J.indexOf(r)){let me=J.match(/^\s*at\s+/);if(me){E=me[0]+P+" (http://localhost)";break}}}for(let k=0;k<y.length;k++){const J=y[k];if(J!==v[k])break;n[J]=!0}}()}class Ue{static get(){return Zone.current.get("ProxyZoneSpec")}static isLoaded(){return Ue.get()instanceof Ue}static assertPresent(){if(!Ue.isLoaded())throw new Error("Expected to be running in 'ProxyZone', but it was not found.");return Ue.get()}constructor(e=null){this.defaultSpecDelegate=e,this.name="ProxyZone",this._delegateSpec=null,this.properties={ProxyZoneSpec:this},this.propertyKeys=null,this.lastTaskState=null,this.isNeedToTriggerHasTask=!1,this.tasks=[],this.setDelegate(e)}setDelegate(e){const n=this._delegateSpec!==e;this._delegateSpec=e,this.propertyKeys&&this.propertyKeys.forEach(c=>delete this.properties[c]),this.propertyKeys=null,e&&e.properties&&(this.propertyKeys=Object.keys(e.properties),this.propertyKeys.forEach(c=>this.properties[c]=e.properties[c])),n&&this.lastTaskState&&(this.lastTaskState.macroTask||this.lastTaskState.microTask)&&(this.isNeedToTriggerHasTask=!0)}getDelegate(){return this._delegateSpec}resetDelegate(){this.getDelegate(),this.setDelegate(this.defaultSpecDelegate)}tryTriggerHasTask(e,n,c){this.isNeedToTriggerHasTask&&this.lastTaskState&&(this.isNeedToTriggerHasTask=!1,this.onHasTask(e,n,c,this.lastTaskState))}removeFromTasks(e){if(this.tasks)for(let n=0;n<this.tasks.length;n++)if(this.tasks[n]===e)return void this.tasks.splice(n,1)}getAndClearPendingTasksInfo(){if(0===this.tasks.length)return"";const n="--Pending async tasks are: ["+this.tasks.map(c=>{const r=c.data&&Object.keys(c.data).map(P=>P+":"+c.data[P]).join(",");return`type: ${c.type}, source: ${c.source}, args: {${r}}`})+"]";return this.tasks=[],n}onFork(e,n,c,r){return this._delegateSpec&&this._delegateSpec.onFork?this._delegateSpec.onFork(e,n,c,r):e.fork(c,r)}onIntercept(e,n,c,r,P){return this._delegateSpec&&this._delegateSpec.onIntercept?this._delegateSpec.onIntercept(e,n,c,r,P):e.intercept(c,r,P)}onInvoke(e,n,c,r,P,E,R){return this.tryTriggerHasTask(e,n,c),this._delegateSpec&&this._delegateSpec.onInvoke?this._delegateSpec.onInvoke(e,n,c,r,P,E,R):e.invoke(c,r,P,E,R)}onHandleError(e,n,c,r){return this._delegateSpec&&this._delegateSpec.onHandleError?this._delegateSpec.onHandleError(e,n,c,r):e.handleError(c,r)}onScheduleTask(e,n,c,r){return"eventTask"!==r.type&&this.tasks.push(r),this._delegateSpec&&this._delegateSpec.onScheduleTask?this._delegateSpec.onScheduleTask(e,n,c,r):e.scheduleTask(c,r)}onInvokeTask(e,n,c,r,P,E){return"eventTask"!==r.type&&this.removeFromTasks(r),this.tryTriggerHasTask(e,n,c),this._delegateSpec&&this._delegateSpec.onInvokeTask?this._delegateSpec.onInvokeTask(e,n,c,r,P,E):e.invokeTask(c,r,P,E)}onCancelTask(e,n,c,r){return"eventTask"!==r.type&&this.removeFromTasks(r),this.tryTriggerHasTask(e,n,c),this._delegateSpec&&this._delegateSpec.onCancelTask?this._delegateSpec.onCancelTask(e,n,c,r):e.cancelTask(c,r)}onHasTask(e,n,c,r){this.lastTaskState=r,this._delegateSpec&&this._delegateSpec.onHasTask?this._delegateSpec.onHasTask(e,n,c,r):e.hasTask(c,r)}}!function nt(C){ut(C),function tt(C){C.ProxyZoneSpec=Ue}(C),function ct(C){C.SyncTestZoneSpec=class e{constructor(c){this.runZone=C.current,this.name="syncTestZone for "+c}onScheduleTask(c,r,P,E){switch(E.type){case"microTask":case"macroTask":throw new Error(`Cannot call ${E.source} from within a sync test (${this.name}).`);case"eventTask":E=c.scheduleTask(P,E)}return E}}}(C),function we(C){C.__load_patch("jasmine",(e,n,c)=>{if(!n)throw new Error("Missing: zone.js");if(typeof jest<"u"||typeof jasmine>"u"||jasmine.__zone_patch__)return;jasmine.__zone_patch__=!0;const P=n.SyncTestZoneSpec,E=n.ProxyZoneSpec;if(!P)throw new Error("Missing: SyncTestZoneSpec");if(!E)throw new Error("Missing: ProxyZoneSpec");const R=n.current,g=n.__symbol__,te=!0===e[g("fakeAsyncDisablePatchingClock")],se=!te&&(!0===e[g("fakeAsyncPatchLock")]||!0===e[g("fakeAsyncAutoFakeAsyncWhenClockPatched")]);if(!0!==e[g("ignoreUnhandledRejection")]){const m=jasmine.GlobalErrors;m&&!jasmine[g("GlobalErrors")]&&(jasmine[g("GlobalErrors")]=m,jasmine.GlobalErrors=function(){const b=new m,h=b.install;return h&&!b[g("install")]&&(b[g("install")]=h,b.install=function(){const y=typeof process<"u"&&!!process.on,v=y?process.listeners("unhandledRejection"):e.eventListeners("unhandledrejection"),k=h.apply(this,arguments);return y?process.removeAllListeners("unhandledRejection"):e.removeAllListeners("unhandledrejection"),v&&v.forEach(J=>{y?process.on("unhandledRejection",J):e.addEventListener("unhandledrejection",J)}),k}),b})}const ie=jasmine.getEnv();if(["describe","xdescribe","fdescribe"].forEach(m=>{let b=ie[m];ie[m]=function(h,y){return b.call(this,h,function Ee(m,b){return function(){return R.fork(new P(`jasmine.describe#${m}`)).run(b,this,arguments)}}(h,y))}}),["it","xit","fit"].forEach(m=>{let b=ie[m];ie[g(m)]=b,ie[m]=function(h,y,v){return arguments[1]=S(y),b.apply(this,arguments)}}),["beforeEach","afterEach","beforeAll","afterAll"].forEach(m=>{let b=ie[m];ie[g(m)]=b,ie[m]=function(h,y){return arguments[0]=S(h),b.apply(this,arguments)}}),!te){const m=jasmine[g("clock")]=jasmine.clock;jasmine.clock=function(){const b=m.apply(this,arguments);if(!b[g("patched")]){b[g("patched")]=g("patched");const h=b[g("tick")]=b.tick;b.tick=function(){const v=n.current.get("FakeAsyncTestZoneSpec");return v?v.tick.apply(v,arguments):h.apply(this,arguments)};const y=b[g("mockDate")]=b.mockDate;b.mockDate=function(){const v=n.current.get("FakeAsyncTestZoneSpec");if(v){const k=arguments.length>0?arguments[0]:new Date;return v.setFakeBaseSystemTime.apply(v,k&&"function"==typeof k.getTime?[k.getTime()]:arguments)}return y.apply(this,arguments)},se&&["install","uninstall"].forEach(v=>{const k=b[g(v)]=b[v];b[v]=function(){if(!n.FakeAsyncTestZoneSpec)return k.apply(this,arguments);jasmine[g("clockInstalled")]="install"===v}})}return b}}if(!jasmine[n.__symbol__("createSpyObj")]){const m=jasmine.createSpyObj;jasmine[n.__symbol__("createSpyObj")]=m,jasmine.createSpyObj=function(){const b=Array.prototype.slice.call(arguments);let y;if(b.length>=3&&b[2]){const v=Object.defineProperty;Object.defineProperty=function(k,J,me){return v.call(this,k,J,{...me,configurable:!0,enumerable:!0})};try{y=m.apply(this,b)}finally{Object.defineProperty=v}}else y=m.apply(this,b);return y}}function H(m,b,h,y){const v=!!jasmine[g("clockInstalled")],k=h.testProxyZone;if(v&&se){const J=n[n.__symbol__("fakeAsyncTest")];J&&"function"==typeof J.fakeAsync&&(m=J.fakeAsync(m))}return y?k.run(m,b,[y]):k.run(m,b)}function S(m){return m&&(m.length?function(b){return H(m,this,this.queueRunner,b)}:function(){return H(m,this,this.queueRunner)})}const V=jasmine.QueueRunner;jasmine.QueueRunner=function(m){function b(h){h.onComplete&&(h.onComplete=(J=>()=>{this.testProxyZone=null,this.testProxyZoneSpec=null,R.scheduleMicroTask("jasmine.onComplete",J)})(h.onComplete));const y=e[n.__symbol__("setTimeout")],v=e[n.__symbol__("clearTimeout")];y&&(h.timeout={setTimeout:y||e.setTimeout,clearTimeout:v||e.clearTimeout}),jasmine.UserContext?(h.userContext||(h.userContext=new jasmine.UserContext),h.userContext.queueRunner=this):(h.userContext||(h.userContext={}),h.userContext.queueRunner=this);const k=h.onException;h.onException=function(J){if(J&&"Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL."===J.message){const me=this&&this.testProxyZoneSpec;if(me){const Qe=me.getAndClearPendingTasksInfo();try{J.message+=Qe}catch{}}}k&&k.call(this,J)},m.call(this,h)}return function(m,b){for(const y in b)b.hasOwnProperty(y)&&(m[y]=b[y]);function h(){this.constructor=m}m.prototype=null===b?Object.create(b):(h.prototype=b.prototype,new h)}(b,m),b.prototype.execute=function(){let h=n.current,y=!1;for(;h;){if(h===R){y=!0;break}h=h.parent}if(!y)throw new Error("Unexpected Zone: "+n.current.name);this.testProxyZoneSpec=new E,this.testProxyZone=R.fork(this.testProxyZoneSpec),n.currentTask?m.prototype.execute.call(this):n.current.scheduleMicroTask("jasmine.execute().forceTask",()=>V.prototype.execute.call(this))},b}(V)})}(C),function Se(C){C.__load_patch("jest",(e,n,c)=>{if(typeof jest>"u"||jest.__zone_patch__)return;n[c.symbol("ignoreConsoleErrorUncaughtError")]=!0,jest.__zone_patch__=!0;const r=n.ProxyZoneSpec,P=n.SyncTestZoneSpec;if(!r)throw new Error("Missing ProxyZoneSpec");const E=n.current,R=E.fork(new P("jest.describe")),g=new r,te=E.fork(g);function ie(H){return function(...S){return R.run(H,this,S)}}function Ee(H,S=!1){if("function"!=typeof H)return H;const V=function(){if(!0===n[c.symbol("useFakeTimersCalled")]&&H&&!H.isFakeAsync){const m=n[n.__symbol__("fakeAsyncTest")];m&&"function"==typeof m.fakeAsync&&(H=m.fakeAsync(H))}return g.isTestFunc=S,te.run(H,null,arguments)};return Object.defineProperty(V,"length",{configurable:!0,writable:!0,enumerable:!1}),V.length=H.length,V}["describe","xdescribe","fdescribe"].forEach(H=>{let S=e[H];e[n.__symbol__(H)]||(e[n.__symbol__(H)]=S,e[H]=function(...V){return V[1]=ie(V[1]),S.apply(this,V)},e[H].each=function se(H){return function(...S){const V=H.apply(this,S);return function(...m){return m[1]=ie(m[1]),V.apply(this,m)}}}(S.each))}),e.describe.only=e.fdescribe,e.describe.skip=e.xdescribe,["it","xit","fit","test","xtest"].forEach(H=>{let S=e[H];e[n.__symbol__(H)]||(e[n.__symbol__(H)]=S,e[H]=function(...V){return V[1]=Ee(V[1],!0),S.apply(this,V)},e[H].each=function ve(H){return function(...S){return function(...V){return V[1]=Ee(V[1]),H.apply(this,S).apply(this,V)}}}(S.each),e[H].todo=S.todo)}),e.it.only=e.fit,e.it.skip=e.xit,e.test.only=e.fit,e.test.skip=e.xit,["beforeEach","afterEach","beforeAll","afterAll"].forEach(H=>{let S=e[H];e[n.__symbol__(H)]||(e[n.__symbol__(H)]=S,e[H]=function(...V){return V[0]=Ee(V[0]),S.apply(this,V)})}),n.patchJestObject=function(S,V=!1){function m(){return!!n.current.get("FakeAsyncTestZoneSpec")}function b(){const h=n.current.get("ProxyZoneSpec");return h&&h.isTestFunc}S[c.symbol("fakeTimers")]||(S[c.symbol("fakeTimers")]=!0,c.patchMethod(S,"_checkFakeTimers",h=>function(y,v){return!!m()||h.apply(y,v)}),c.patchMethod(S,"useFakeTimers",h=>function(y,v){return n[c.symbol("useFakeTimersCalled")]=!0,V||b()?h.apply(y,v):y}),c.patchMethod(S,"useRealTimers",h=>function(y,v){return n[c.symbol("useFakeTimersCalled")]=!1,V||b()?h.apply(y,v):y}),c.patchMethod(S,"setSystemTime",h=>function(y,v){const k=n.current.get("FakeAsyncTestZoneSpec");if(!k||!m())return h.apply(y,v);k.setFakeBaseSystemTime(v[0])}),c.patchMethod(S,"getRealSystemTime",h=>function(y,v){const k=n.current.get("FakeAsyncTestZoneSpec");return k&&m()?k.getRealSystemTime():h.apply(y,v)}),c.patchMethod(S,"runAllTicks",h=>function(y,v){const k=n.current.get("FakeAsyncTestZoneSpec");if(!k)return h.apply(y,v);k.flushMicrotasks()}),c.patchMethod(S,"runAllTimers",h=>function(y,v){const k=n.current.get("FakeAsyncTestZoneSpec");if(!k)return h.apply(y,v);k.flush(100,!0)}),c.patchMethod(S,"advanceTimersByTime",h=>function(y,v){const k=n.current.get("FakeAsyncTestZoneSpec");if(!k)return h.apply(y,v);k.tick(v[0])}),c.patchMethod(S,"runOnlyPendingTimers",h=>function(y,v){const k=n.current.get("FakeAsyncTestZoneSpec");if(!k)return h.apply(y,v);k.flushOnlyPendingTimers()}),c.patchMethod(S,"advanceTimersToNextTimer",h=>function(y,v){const k=n.current.get("FakeAsyncTestZoneSpec");if(!k)return h.apply(y,v);k.tickToNext(v[0])}),c.patchMethod(S,"clearAllTimers",h=>function(y,v){const k=n.current.get("FakeAsyncTestZoneSpec");if(!k)return h.apply(y,v);k.removeAllTimers()}),c.patchMethod(S,"getTimerCount",h=>function(y,v){const k=n.current.get("FakeAsyncTestZoneSpec");return k?k.getTimerCount():h.apply(y,v)}))}})}(C),function Ne(C){C.__load_patch("mocha",(e,n)=>{const c=e.Mocha;if(typeof c>"u")return;if(typeof n>"u")throw new Error("Missing Zone.js");const r=n.ProxyZoneSpec,P=n.SyncTestZoneSpec;if(!r)throw new Error("Missing ProxyZoneSpec");if(c.__zone_patch__)throw new Error('"Mocha" has already been patched with "Zone".');c.__zone_patch__=!0;const E=n.current,R=E.fork(new P("Mocha.describe"));let g=null;const te=E.fork(new r),se={after:e.after,afterEach:e.afterEach,before:e.before,beforeEach:e.beforeEach,describe:e.describe,it:e.it};function ve(S,V,m){for(let b=0;b<S.length;b++){let h=S[b];"function"==typeof h&&(S[b]=0===h.length?V(h):m(h),S[b].toString=function(){return h.toString()})}return S}function ie(S){return ve(S,function(m){return function(){return R.run(m,this,arguments)}})}function Ee(S){return ve(S,function(b){return function(){return g.run(b,this)}},function(b){return function(h){return g.run(b,this,[h])}})}function H(S){return ve(S,function(b){return function(){return te.run(b,this)}},function(b){return function(h){return te.run(b,this,[h])}})}var S,V;e.describe=e.suite=function(){return se.describe.apply(this,ie(arguments))},e.xdescribe=e.suite.skip=e.describe.skip=function(){return se.describe.skip.apply(this,ie(arguments))},e.describe.only=e.suite.only=function(){return se.describe.only.apply(this,ie(arguments))},e.it=e.specify=e.test=function(){return se.it.apply(this,Ee(arguments))},e.xit=e.xspecify=e.it.skip=function(){return se.it.skip.apply(this,Ee(arguments))},e.it.only=e.test.only=function(){return se.it.only.apply(this,Ee(arguments))},e.after=e.suiteTeardown=function(){return se.after.apply(this,H(arguments))},e.afterEach=e.teardown=function(){return se.afterEach.apply(this,Ee(arguments))},e.before=e.suiteSetup=function(){return se.before.apply(this,H(arguments))},e.beforeEach=e.setup=function(){return se.beforeEach.apply(this,Ee(arguments))},S=c.Runner.prototype.runTest,V=c.Runner.prototype.run,c.Runner.prototype.runTest=function(m){n.current.scheduleMicroTask("mocha.forceTask",()=>{S.call(this,m)})},c.Runner.prototype.run=function(m){return this.on("test",b=>{g=E.fork(new r)}),this.on("fail",(b,h)=>{const y=g&&g.get("ProxyZoneSpec");if(y&&h)try{h.message+=y.getAndClearPendingTasksInfo()}catch{}}),V.call(this,m)}})}(C),function ft(C){C.AsyncTestZoneSpec=Ge,C.__load_patch("asynctest",(e,n,c)=>{function r(P,E,R,g){const te=n.current,se=n.AsyncTestZoneSpec;if(void 0===se)throw new Error("AsyncTestZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/async-test");const ve=n.ProxyZoneSpec;if(!ve)throw new Error("ProxyZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/proxy");const ie=ve.get();ve.assertPresent();const Ee=n.current.getZoneWith("ProxyZoneSpec"),H=ie.getDelegate();return Ee.parent.run(()=>{const S=new se(()=>{ie.getDelegate()==S&&ie.setDelegate(H),S.unPatchPromiseForTest(),te.run(()=>{R()})},V=>{ie.getDelegate()==S&&ie.setDelegate(H),S.unPatchPromiseForTest(),te.run(()=>{g(V)})},"test");ie.setDelegate(S),S.patchPromiseForTest()}),n.current.runGuarded(P,E)}n[c.symbol("asyncTest")]=function(E){return e.jasmine?function(R){R||((R=function(){}).fail=function(g){throw g}),r(E,this,R,g=>{if("string"==typeof g)return R.fail(new Error(g));R.fail(g)})}:function(){return new Promise((R,g)=>{r(E,this,R,g)})}}})}(C),function _t(C){C.FakeAsyncTestZoneSpec=le,C.__load_patch("fakeasync",(e,n,c)=>{n[c.symbol("fakeAsyncTest")]={resetFakeAsyncZone:Ye,flushMicrotasks:et,discardPeriodicTasks:dt,tick:Ve,flush:ge,fakeAsync:re}},!0),De={setTimeout:ce.setTimeout,setInterval:ce.setInterval,clearTimeout:ce.clearTimeout,clearInterval:ce.clearInterval,nativeSetTimeout:ce[C.__symbol__("setTimeout")],nativeClearTimeout:ce[C.__symbol__("clearTimeout")]},Ae.nextId=Ae.getNextId()}(C),function lt(C){C.__load_patch("promisefortest",(e,n,c)=>{const r=c.symbol("state"),E=c.symbol("parentUnresolved");Promise[c.symbol("patchPromiseForTest")]=function(){let g=Promise[n.__symbol__("ZonePromiseThen")];g||(g=Promise[n.__symbol__("ZonePromiseThen")]=Promise.prototype.then,Promise.prototype.then=function(){const te=g.apply(this,arguments);if(null===this[r]){const se=n.current.get("AsyncTestZoneSpec");se&&(se.unresolvedChainedPromiseCount++,te[E]=!0)}return te})},Promise[c.symbol("unPatchPromiseForTest")]=function(){const g=Promise[n.__symbol__("ZonePromiseThen")];g&&(Promise.prototype.then=g,Promise[n.__symbol__("ZonePromiseThen")]=void 0)}})}(C)}(Zone)},935:()=>{const we=globalThis;function Se(t){return(we.__Zone_symbol_prefix||"__zone_symbol__")+t}const xe=Object.getOwnPropertyDescriptor,Je=Object.defineProperty,Ge=Object.getPrototypeOf,ft=Object.create,ce=Array.prototype.slice,Oe="addEventListener",Me="removeEventListener",De=Se(Oe),ot=Se(Me),Ae="true",le="false",pe=Se("");function Ke(t,o){return Zone.current.wrap(t,o)}function Ye(t,o,f,s,l){return Zone.current.scheduleMacroTask(t,o,f,s,l)}const re=Se,He=typeof window<"u",Ve=He?window:void 0,ge=He&&Ve||globalThis,dt="removeAttribute";function et(t,o){for(let f=t.length-1;f>=0;f--)"function"==typeof t[f]&&(t[f]=Ke(t[f],o+"_"+f));return t}function ut(t){return!t||!1!==t.writable&&!("function"==typeof t.get&&typeof t.set>"u")}const Ue=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope,tt=!("nw"in ge)&&typeof ge.process<"u"&&"[object process]"===ge.process.toString(),ct=!tt&&!Ue&&!(!He||!Ve.HTMLElement),lt=typeof ge.process<"u"&&"[object process]"===ge.process.toString()&&!Ue&&!(!He||!Ve.HTMLElement),nt={},C=re("enable_beforeunload"),e=function(t){if(!(t=t||ge.event))return;let o=nt[t.type];o||(o=nt[t.type]=re("ON_PROPERTY"+t.type));const f=this||t.target||ge,s=f[o];let l;return ct&&f===Ve&&"error"===t.type?(l=s&&s.call(this,t.message,t.filename,t.lineno,t.colno,t.error),!0===l&&t.preventDefault()):(l=s&&s.apply(this,arguments),"beforeunload"===t.type&&ge[C]&&"string"==typeof l?t.returnValue=l:null!=l&&!l&&t.preventDefault()),l};function n(t,o,f){let s=xe(t,o);if(!s&&f&&xe(f,o)&&(s={enumerable:!0,configurable:!0}),!s||!s.configurable)return;const l=re("on"+o+"patched");if(t.hasOwnProperty(l)&&t[l])return;delete s.writable,delete s.value;const T=s.get,D=s.set,O=o.slice(2);let j=nt[O];j||(j=nt[O]=re("ON_PROPERTY"+O)),s.set=function(G){let A=this;!A&&t===ge&&(A=ge),A&&("function"==typeof A[j]&&A.removeEventListener(O,e),D&&D.call(A,null),A[j]=G,"function"==typeof G&&A.addEventListener(O,e,!1))},s.get=function(){let G=this;if(!G&&t===ge&&(G=ge),!G)return null;const A=G[j];if(A)return A;if(T){let q=T.call(this);if(q)return s.set.call(this,q),"function"==typeof G[dt]&&G.removeAttribute(o),q}return null},Je(t,o,s),t[l]=!0}function c(t,o,f){if(o)for(let s=0;s<o.length;s++)n(t,"on"+o[s],f);else{const s=[];for(const l in t)"on"==l.slice(0,2)&&s.push(l);for(let l=0;l<s.length;l++)n(t,s[l],f)}}const r=re("originalInstance");function P(t){const o=ge[t];if(!o)return;ge[re(t)]=o,ge[t]=function(){const l=et(arguments,t);switch(l.length){case 0:this[r]=new o;break;case 1:this[r]=new o(l[0]);break;case 2:this[r]=new o(l[0],l[1]);break;case 3:this[r]=new o(l[0],l[1],l[2]);break;case 4:this[r]=new o(l[0],l[1],l[2],l[3]);break;default:throw new Error("Arg list too long.")}},g(ge[t],o);const f=new o(function(){});let s;for(s in f)"XMLHttpRequest"===t&&"responseBlob"===s||function(l){"function"==typeof f[l]?ge[t].prototype[l]=function(){return this[r][l].apply(this[r],arguments)}:Je(ge[t].prototype,l,{set:function(T){"function"==typeof T?(this[r][l]=Ke(T,t+"."+l),g(this[r][l],T)):this[r][l]=T},get:function(){return this[r][l]}})}(s);for(s in o)"prototype"!==s&&o.hasOwnProperty(s)&&(ge[t][s]=o[s])}function E(t,o,f){let s=t;for(;s&&!s.hasOwnProperty(o);)s=Ge(s);!s&&t[o]&&(s=t);const l=re(o);let T=null;if(s&&(!(T=s[l])||!s.hasOwnProperty(l))&&(T=s[l]=s[o],ut(s&&xe(s,o)))){const O=f(T,l,o);s[o]=function(){return O(this,arguments)},g(s[o],T)}return T}function R(t,o,f){let s=null;function l(T){const D=T.data;return D.args[D.cbIdx]=function(){T.invoke.apply(this,arguments)},s.apply(D.target,D.args),T}s=E(t,o,T=>function(D,O){const j=f(D,O);return j.cbIdx>=0&&"function"==typeof O[j.cbIdx]?Ye(j.name,O[j.cbIdx],j,l):T.apply(D,O)})}function g(t,o){t[re("OriginalDelegate")]=o}let te=!1,se=!1;function ie(){if(te)return se;te=!0;try{const t=Ve.navigator.userAgent;(-1!==t.indexOf("MSIE ")||-1!==t.indexOf("Trident/")||-1!==t.indexOf("Edge/"))&&(se=!0)}catch{}return se}function Ee(t){return"function"==typeof t}function H(t){return"number"==typeof t}let S=!1;if(typeof window<"u")try{const t=Object.defineProperty({},"passive",{get:function(){S=!0}});window.addEventListener("test",t,t),window.removeEventListener("test",t,t)}catch{S=!1}const V={useG:!0},m={},b={},h=new RegExp("^"+pe+"(\\w+)(true|false)$"),y=re("propagationStopped");function v(t,o){const f=(o?o(t):t)+le,s=(o?o(t):t)+Ae,l=pe+f,T=pe+s;m[t]={},m[t][le]=l,m[t][Ae]=T}function k(t,o,f,s){const l=s&&s.add||Oe,T=s&&s.rm||Me,D=s&&s.listeners||"eventListeners",O=s&&s.rmAll||"removeAllListeners",j=re(l),G="."+l+":",A="prependListener",q="."+A+":",ee=function(L,w,oe){if(L.isRemoved)return;const ue=L.callback;let Pe;"object"==typeof ue&&ue.handleEvent&&(L.callback=M=>ue.handleEvent(M),L.originalDelegate=ue);try{L.invoke(L,w,[oe])}catch(M){Pe=M}const he=L.options;return he&&"object"==typeof he&&he.once&&w[T].call(w,oe.type,L.originalDelegate?L.originalDelegate:L.callback,he),Pe};function ae(L,w,oe){if(!(w=w||t.event))return;const ue=L||w.target||t,Pe=ue[m[w.type][oe?Ae:le]];if(Pe){const he=[];if(1===Pe.length){const M=ee(Pe[0],ue,w);M&&he.push(M)}else{const M=Pe.slice();for(let Te=0;Te<M.length&&(!w||!0!==w[y]);Te++){const B=ee(M[Te],ue,w);B&&he.push(B)}}if(1===he.length)throw he[0];for(let M=0;M<he.length;M++){const Te=he[M];o.nativeScheduleMicroTask(()=>{throw Te})}}}const _e=function(L){return ae(this,L,!1)},Ce=function(L){return ae(this,L,!0)};function Re(L,w){if(!L)return!1;let oe=!0;w&&void 0!==w.useG&&(oe=w.useG);const ue=w&&w.vh;let Pe=!0;w&&void 0!==w.chkDup&&(Pe=w.chkDup);let he=!1;w&&void 0!==w.rt&&(he=w.rt);let M=L;for(;M&&!M.hasOwnProperty(l);)M=Ge(M);if(!M&&L[l]&&(M=L),!M||M[j])return!1;const Te=w&&w.eventNameToString,B={},z=M[j]=M[l],x=M[re(T)]=M[T],Q=M[re(D)]=M[D],Ie=M[re(O)]=M[O];let ye;w&&w.prepend&&(ye=M[re(w.prepend)]=M[w.prepend]);const ke=oe?function(u){if(!B.isExisting)return z.call(B.target,B.eventName,B.capture?Ce:_e,B.options)}:function(u){return z.call(B.target,B.eventName,u.invoke,B.options)},ne=oe?function(u){if(!u.isRemoved){const _=m[u.eventName];let N;_&&(N=_[u.capture?Ae:le]);const W=N&&u.target[N];if(W)for(let F=0;F<W.length;F++)if(W[F]===u){W.splice(F,1),u.isRemoved=!0,u.removeAbortListener&&(u.removeAbortListener(),u.removeAbortListener=null),0===W.length&&(u.allRemoved=!0,u.target[N]=null);break}}if(u.allRemoved)return x.call(u.target,u.eventName,u.capture?Ce:_e,u.options)}:function(u){return x.call(u.target,u.eventName,u.invoke,u.options)},ze=w&&w.diff?w.diff:function(u,_){const N=typeof _;return"function"===N&&u.callback===_||"object"===N&&u.originalDelegate===_},We=Zone[re("UNPATCHED_EVENTS")],Fe=t[re("PASSIVE_EVENTS")],d=function(u,_,N,W,F=!1,$=!1){return function(){const K=this||t;let Y=arguments[0];w&&w.transferEventName&&(Y=w.transferEventName(Y));let fe=arguments[1];if(!fe)return u.apply(this,arguments);if(tt&&"uncaughtException"===Y)return u.apply(this,arguments);let de=!1;if("function"!=typeof fe){if(!fe.handleEvent)return u.apply(this,arguments);de=!0}if(ue&&!ue(u,fe,K,arguments))return;const Xe=S&&!!Fe&&-1!==Fe.indexOf(Y),Ze=function p(u){if("object"==typeof u&&null!==u){const _={...u};return u.signal&&(_.signal=u.signal),_}return u}(function X(u,_){return!S&&"object"==typeof u&&u?!!u.capture:S&&_?"boolean"==typeof u?{capture:u,passive:!0}:u?"object"==typeof u&&!1!==u.passive?{...u,passive:!0}:u:{passive:!0}:u}(arguments[2],Xe)),st=Ze?.signal;if(st?.aborted)return;if(We)for(let Le=0;Le<We.length;Le++)if(Y===We[Le])return Xe?u.call(K,Y,fe,Ze):u.apply(this,arguments);const pt=!!Ze&&("boolean"==typeof Ze||Ze.capture),Et=!(!Ze||"object"!=typeof Ze)&&Ze.once,Zt=Zone.current;let mt=m[Y];mt||(v(Y,Te),mt=m[Y]);const bt=mt[pt?Ae:le];let ht,it=K[bt],Pt=!1;if(it){if(Pt=!0,Pe)for(let Le=0;Le<it.length;Le++)if(ze(it[Le],fe))return}else it=K[bt]=[];const vt=K.constructor.name,St=b[vt];St&&(ht=St[Y]),ht||(ht=vt+_+(Te?Te(Y):Y)),B.options=Ze,Et&&(B.options.once=!1),B.target=K,B.capture=pt,B.eventName=Y,B.isExisting=Pt;const at=oe?V:void 0;at&&(at.taskData=B),st&&(B.options.signal=void 0);const je=Zt.scheduleEventTask(ht,fe,at,N,W);if(st){B.options.signal=st;const Le=()=>je.zone.cancelTask(je);u.call(st,"abort",Le,{once:!0}),je.removeAbortListener=()=>st.removeEventListener("abort",Le)}return B.target=null,at&&(at.taskData=null),Et&&(B.options.once=!0),!S&&"boolean"==typeof je.options||(je.options=Ze),je.target=K,je.capture=pt,je.eventName=Y,de&&(je.originalDelegate=fe),$?it.unshift(je):it.push(je),F?K:void 0}};return M[l]=d(z,G,ke,ne,he),ye&&(M[A]=d(ye,q,function(u){return ye.call(B.target,B.eventName,u.invoke,B.options)},ne,he,!0)),M[T]=function(){const u=this||t;let _=arguments[0];w&&w.transferEventName&&(_=w.transferEventName(_));const N=arguments[2],W=!!N&&("boolean"==typeof N||N.capture),F=arguments[1];if(!F)return x.apply(this,arguments);if(ue&&!ue(x,F,u,arguments))return;const $=m[_];let K;$&&(K=$[W?Ae:le]);const Y=K&&u[K];if(Y)for(let fe=0;fe<Y.length;fe++){const de=Y[fe];if(ze(de,F))return Y.splice(fe,1),de.isRemoved=!0,0!==Y.length||(de.allRemoved=!0,u[K]=null,W||"string"!=typeof _)||(u[pe+"ON_PROPERTY"+_]=null),de.zone.cancelTask(de),he?u:void 0}return x.apply(this,arguments)},M[D]=function(){const u=this||t;let _=arguments[0];w&&w.transferEventName&&(_=w.transferEventName(_));const N=[],W=J(u,Te?Te(_):_);for(let F=0;F<W.length;F++){const $=W[F];N.push($.originalDelegate?$.originalDelegate:$.callback)}return N},M[O]=function(){const u=this||t;let _=arguments[0];if(_){w&&w.transferEventName&&(_=w.transferEventName(_));const N=m[_];if(N){const $=u[N[le]],K=u[N[Ae]];if($){const Y=$.slice();for(let fe=0;fe<Y.length;fe++){const de=Y[fe];this[T].call(this,_,de.originalDelegate?de.originalDelegate:de.callback,de.options)}}if(K){const Y=K.slice();for(let fe=0;fe<Y.length;fe++){const de=Y[fe];this[T].call(this,_,de.originalDelegate?de.originalDelegate:de.callback,de.options)}}}}else{const N=Object.keys(u);for(let W=0;W<N.length;W++){const $=h.exec(N[W]);let K=$&&$[1];K&&"removeListener"!==K&&this[O].call(this,K)}this[O].call(this,"removeListener")}if(he)return this},g(M[l],z),g(M[T],x),Ie&&g(M[O],Ie),Q&&g(M[D],Q),!0}let be=[];for(let L=0;L<f.length;L++)be[L]=Re(f[L],s);return be}function J(t,o){if(!o){const T=[];for(let D in t){const O=h.exec(D);let j=O&&O[1];if(j&&(!o||j===o)){const G=t[D];if(G)for(let A=0;A<G.length;A++)T.push(G[A])}}return T}let f=m[o];f||(v(o),f=m[o]);const s=t[f[le]],l=t[f[Ae]];return s?l?s.concat(l):s.slice():l?l.slice():[]}function me(t,o){const f=t.Event;f&&f.prototype&&o.patchMethod(f.prototype,"stopImmediatePropagation",s=>function(l,T){l[y]=!0,s&&s.apply(l,T)})}const qe=re("zoneTask");function rt(t,o,f,s){let l=null,T=null;f+=s;const D={};function O(G){const A=G.data;A.args[0]=function(){return G.invoke.apply(this,arguments)};const q=l.apply(t,A.args);return H(q)?A.handleId=q:(A.handle=q,A.isRefreshable=Ee(q.refresh)),G}function j(G){const{handle:A,handleId:q}=G.data;return T.call(t,A??q)}l=E(t,o+=s,G=>function(A,q){if(Ee(q[0])){const ee={isRefreshable:!1,isPeriodic:"Interval"===s,delay:"Timeout"===s||"Interval"===s?q[1]||0:void 0,args:q},ae=q[0];q[0]=function(){try{return ae.apply(this,arguments)}finally{const{handle:oe,handleId:ue,isPeriodic:Pe,isRefreshable:he}=ee;!Pe&&!he&&(ue?delete D[ue]:oe&&(oe[qe]=null))}};const _e=Ye(o,q[0],ee,O,j);if(!_e)return _e;const{handleId:Ce,handle:Re,isRefreshable:be,isPeriodic:L}=_e.data;if(Ce)D[Ce]=_e;else if(Re&&(Re[qe]=_e,be&&!L)){const w=Re.refresh;Re.refresh=function(){const{zone:oe,state:ue}=_e;return"notScheduled"===ue?(_e._state="scheduled",oe._updateTaskCount(_e,1)):"running"===ue&&(_e._state="scheduling"),w.call(this)}}return Re??Ce??_e}return G.apply(t,q)}),T=E(t,f,G=>function(A,q){const ee=q[0];let ae;H(ee)?(ae=D[ee],delete D[ee]):(ae=ee?.[qe],ae?ee[qe]=null:ae=ee),ae?.type?ae.cancelFn&&ae.zone.cancelTask(ae):G.apply(t,q)})}function yt(t,o,f){if(!f||0===f.length)return o;const s=f.filter(T=>T.target===t);if(!s||0===s.length)return o;const l=s[0].ignoreProperties;return o.filter(T=>-1===l.indexOf(T))}function kt(t,o,f,s){t&&c(t,yt(t,o,f),s)}function Tt(t){return Object.getOwnPropertyNames(t).filter(o=>o.startsWith("on")&&o.length>2).map(o=>o.substring(2))}function Mt(t,o,f,s,l){const T=Zone.__symbol__(s);if(o[T])return;const D=o[T]=o[s];o[s]=function(O,j,G){return j&&j.prototype&&l.forEach(function(A){const q=`${f}.${s}::`+A,ee=j.prototype;try{if(ee.hasOwnProperty(A)){const ae=t.ObjectGetOwnPropertyDescriptor(ee,A);ae&&ae.value?(ae.value=t.wrapWithCurrentZone(ae.value,q),t._redefineProperty(j.prototype,A,ae)):ee[A]&&(ee[A]=t.wrapWithCurrentZone(ee[A],q))}else ee[A]&&(ee[A]=t.wrapWithCurrentZone(ee[A],q))}catch{}}),D.call(o,O,j,G)},t.attachOriginToPatched(o[s],D)}const gt=function $e(){const t=globalThis,o=!0===t[Se("forceDuplicateZoneCheck")];if(t.Zone&&(o||"function"!=typeof t.Zone.__symbol__))throw new Error("Zone already loaded.");return t.Zone??=function Ne(){const t=we.performance;function o(X){t&&t.mark&&t.mark(X)}function f(X,I){t&&t.measure&&t.measure(X,I)}o("Zone");let s=(()=>{class X{static{this.__symbol__=Se}static assertZonePatched(){if(we.Promise!==B.ZoneAwarePromise)throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)")}static get root(){let i=X.current;for(;i.parent;)i=i.parent;return i}static get current(){return x.zone}static get currentTask(){return Q}static __load_patch(i,a,Z=!1){if(B.hasOwnProperty(i)){const U=!0===we[Se("forceDuplicateZoneCheck")];if(!Z&&U)throw Error("Already loaded patch: "+i)}else if(!we["__Zone_disable_"+i]){const U="Zone:"+i;o(U),B[i]=a(we,X,z),f(U,U)}}get parent(){return this._parent}get name(){return this._name}constructor(i,a){this._parent=i,this._name=a?a.name||"unnamed":"<root>",this._properties=a&&a.properties||{},this._zoneDelegate=new T(this,this._parent&&this._parent._zoneDelegate,a)}get(i){const a=this.getZoneWith(i);if(a)return a._properties[i]}getZoneWith(i){let a=this;for(;a;){if(a._properties.hasOwnProperty(i))return a;a=a._parent}return null}fork(i){if(!i)throw new Error("ZoneSpec required!");return this._zoneDelegate.fork(this,i)}wrap(i,a){if("function"!=typeof i)throw new Error("Expecting function got: "+i);const Z=this._zoneDelegate.intercept(this,i,a),U=this;return function(){return U.runGuarded(Z,this,arguments,a)}}run(i,a,Z,U){x={parent:x,zone:this};try{return this._zoneDelegate.invoke(this,i,a,Z,U)}finally{x=x.parent}}runGuarded(i,a=null,Z,U){x={parent:x,zone:this};try{try{return this._zoneDelegate.invoke(this,i,a,Z,U)}catch(ke){if(this._zoneDelegate.handleError(this,ke))throw ke}}finally{x=x.parent}}runTask(i,a,Z){if(i.zone!=this)throw new Error("A task can only be run in the zone of creation! (Creation: "+(i.zone||Re).name+"; Execution: "+this.name+")");const U=i,{type:ke,data:{isPeriodic:ne=!1,isRefreshable:Be=!1}={}}=i;if(i.state===be&&(ke===Te||ke===M))return;const ze=i.state!=oe;ze&&U._transitionTo(oe,w);const We=Q;Q=U,x={parent:x,zone:this};try{ke==M&&i.data&&!ne&&!Be&&(i.cancelFn=void 0);try{return this._zoneDelegate.invokeTask(this,U,a,Z)}catch(Fe){if(this._zoneDelegate.handleError(this,Fe))throw Fe}}finally{const Fe=i.state;if(Fe!==be&&Fe!==Pe)if(ke==Te||ne||Be&&Fe===L)ze&&U._transitionTo(w,oe,L);else{const p=U._zoneDelegates;this._updateTaskCount(U,-1),ze&&U._transitionTo(be,oe,be),Be&&(U._zoneDelegates=p)}x=x.parent,Q=We}}scheduleTask(i){if(i.zone&&i.zone!==this){let Z=this;for(;Z;){if(Z===i.zone)throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${i.zone.name}`);Z=Z.parent}}i._transitionTo(L,be);const a=[];i._zoneDelegates=a,i._zone=this;try{i=this._zoneDelegate.scheduleTask(this,i)}catch(Z){throw i._transitionTo(Pe,L,be),this._zoneDelegate.handleError(this,Z),Z}return i._zoneDelegates===a&&this._updateTaskCount(i,1),i.state==L&&i._transitionTo(w,L),i}scheduleMicroTask(i,a,Z,U){return this.scheduleTask(new D(he,i,a,Z,U,void 0))}scheduleMacroTask(i,a,Z,U,ke){return this.scheduleTask(new D(M,i,a,Z,U,ke))}scheduleEventTask(i,a,Z,U,ke){return this.scheduleTask(new D(Te,i,a,Z,U,ke))}cancelTask(i){if(i.zone!=this)throw new Error("A task can only be cancelled in the zone of creation! (Creation: "+(i.zone||Re).name+"; Execution: "+this.name+")");if(i.state===w||i.state===oe){i._transitionTo(ue,w,oe);try{this._zoneDelegate.cancelTask(this,i)}catch(a){throw i._transitionTo(Pe,ue),this._zoneDelegate.handleError(this,a),a}return this._updateTaskCount(i,-1),i._transitionTo(be,ue),i.runCount=-1,i}}_updateTaskCount(i,a){const Z=i._zoneDelegates;-1==a&&(i._zoneDelegates=null);for(let U=0;U<Z.length;U++)Z[U]._updateTaskCount(i.type,a)}}return X})();const l={name:"",onHasTask:(X,I,i,a)=>X.hasTask(i,a),onScheduleTask:(X,I,i,a)=>X.scheduleTask(i,a),onInvokeTask:(X,I,i,a,Z,U)=>X.invokeTask(i,a,Z,U),onCancelTask:(X,I,i,a)=>X.cancelTask(i,a)};class T{get zone(){return this._zone}constructor(I,i,a){this._taskCounts={microTask:0,macroTask:0,eventTask:0},this._zone=I,this._parentDelegate=i,this._forkZS=a&&(a&&a.onFork?a:i._forkZS),this._forkDlgt=a&&(a.onFork?i:i._forkDlgt),this._forkCurrZone=a&&(a.onFork?this._zone:i._forkCurrZone),this._interceptZS=a&&(a.onIntercept?a:i._interceptZS),this._interceptDlgt=a&&(a.onIntercept?i:i._interceptDlgt),this._interceptCurrZone=a&&(a.onIntercept?this._zone:i._interceptCurrZone),this._invokeZS=a&&(a.onInvoke?a:i._invokeZS),this._invokeDlgt=a&&(a.onInvoke?i:i._invokeDlgt),this._invokeCurrZone=a&&(a.onInvoke?this._zone:i._invokeCurrZone),this._handleErrorZS=a&&(a.onHandleError?a:i._handleErrorZS),this._handleErrorDlgt=a&&(a.onHandleError?i:i._handleErrorDlgt),this._handleErrorCurrZone=a&&(a.onHandleError?this._zone:i._handleErrorCurrZone),this._scheduleTaskZS=a&&(a.onScheduleTask?a:i._scheduleTaskZS),this._scheduleTaskDlgt=a&&(a.onScheduleTask?i:i._scheduleTaskDlgt),this._scheduleTaskCurrZone=a&&(a.onScheduleTask?this._zone:i._scheduleTaskCurrZone),this._invokeTaskZS=a&&(a.onInvokeTask?a:i._invokeTaskZS),this._invokeTaskDlgt=a&&(a.onInvokeTask?i:i._invokeTaskDlgt),this._invokeTaskCurrZone=a&&(a.onInvokeTask?this._zone:i._invokeTaskCurrZone),this._cancelTaskZS=a&&(a.onCancelTask?a:i._cancelTaskZS),this._cancelTaskDlgt=a&&(a.onCancelTask?i:i._cancelTaskDlgt),this._cancelTaskCurrZone=a&&(a.onCancelTask?this._zone:i._cancelTaskCurrZone),this._hasTaskZS=null,this._hasTaskDlgt=null,this._hasTaskDlgtOwner=null,this._hasTaskCurrZone=null;const Z=a&&a.onHasTask;(Z||i&&i._hasTaskZS)&&(this._hasTaskZS=Z?a:l,this._hasTaskDlgt=i,this._hasTaskDlgtOwner=this,this._hasTaskCurrZone=this._zone,a.onScheduleTask||(this._scheduleTaskZS=l,this._scheduleTaskDlgt=i,this._scheduleTaskCurrZone=this._zone),a.onInvokeTask||(this._invokeTaskZS=l,this._invokeTaskDlgt=i,this._invokeTaskCurrZone=this._zone),a.onCancelTask||(this._cancelTaskZS=l,this._cancelTaskDlgt=i,this._cancelTaskCurrZone=this._zone))}fork(I,i){return this._forkZS?this._forkZS.onFork(this._forkDlgt,this.zone,I,i):new s(I,i)}intercept(I,i,a){return this._interceptZS?this._interceptZS.onIntercept(this._interceptDlgt,this._interceptCurrZone,I,i,a):i}invoke(I,i,a,Z,U){return this._invokeZS?this._invokeZS.onInvoke(this._invokeDlgt,this._invokeCurrZone,I,i,a,Z,U):i.apply(a,Z)}handleError(I,i){return!this._handleErrorZS||this._handleErrorZS.onHandleError(this._handleErrorDlgt,this._handleErrorCurrZone,I,i)}scheduleTask(I,i){let a=i;if(this._scheduleTaskZS)this._hasTaskZS&&a._zoneDelegates.push(this._hasTaskDlgtOwner),a=this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt,this._scheduleTaskCurrZone,I,i),a||(a=i);else if(i.scheduleFn)i.scheduleFn(i);else{if(i.type!=he)throw new Error("Task is missing scheduleFn.");_e(i)}return a}invokeTask(I,i,a,Z){return this._invokeTaskZS?this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt,this._invokeTaskCurrZone,I,i,a,Z):i.callback.apply(a,Z)}cancelTask(I,i){let a;if(this._cancelTaskZS)a=this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt,this._cancelTaskCurrZone,I,i);else{if(!i.cancelFn)throw Error("Task is not cancelable");a=i.cancelFn(i)}return a}hasTask(I,i){try{this._hasTaskZS&&this._hasTaskZS.onHasTask(this._hasTaskDlgt,this._hasTaskCurrZone,I,i)}catch(a){this.handleError(I,a)}}_updateTaskCount(I,i){const a=this._taskCounts,Z=a[I],U=a[I]=Z+i;if(U<0)throw new Error("More tasks executed then were scheduled.");0!=Z&&0!=U||this.hasTask(this._zone,{microTask:a.microTask>0,macroTask:a.macroTask>0,eventTask:a.eventTask>0,change:I})}}class D{constructor(I,i,a,Z,U,ke){if(this._zone=null,this.runCount=0,this._zoneDelegates=null,this._state="notScheduled",this.type=I,this.source=i,this.data=Z,this.scheduleFn=U,this.cancelFn=ke,!a)throw new Error("callback is not defined");this.callback=a;const ne=this;this.invoke=I===Te&&Z&&Z.useG?D.invokeTask:function(){return D.invokeTask.call(we,ne,this,arguments)}}static invokeTask(I,i,a){I||(I=this),Ie++;try{return I.runCount++,I.zone.runTask(I,i,a)}finally{1==Ie&&Ce(),Ie--}}get zone(){return this._zone}get state(){return this._state}cancelScheduleRequest(){this._transitionTo(be,L)}_transitionTo(I,i,a){if(this._state!==i&&this._state!==a)throw new Error(`${this.type} '${this.source}': can not transition to '${I}', expecting state '${i}'${a?" or '"+a+"'":""}, was '${this._state}'.`);this._state=I,I==be&&(this._zoneDelegates=null)}toString(){return this.data&&typeof this.data.handleId<"u"?this.data.handleId.toString():Object.prototype.toString.call(this)}toJSON(){return{type:this.type,state:this.state,source:this.source,zone:this.zone.name,runCount:this.runCount}}}const O=Se("setTimeout"),j=Se("Promise"),G=Se("then");let ee,A=[],q=!1;function ae(X){if(ee||we[j]&&(ee=we[j].resolve(0)),ee){let I=ee[G];I||(I=ee.then),I.call(ee,X)}else we[O](X,0)}function _e(X){0===Ie&&0===A.length&&ae(Ce),X&&A.push(X)}function Ce(){if(!q){for(q=!0;A.length;){const X=A;A=[];for(let I=0;I<X.length;I++){const i=X[I];try{i.zone.runTask(i,null,null)}catch(a){z.onUnhandledError(a)}}}z.microtaskDrainDone(),q=!1}}const Re={name:"NO ZONE"},be="notScheduled",L="scheduling",w="scheduled",oe="running",ue="canceling",Pe="unknown",he="microTask",M="macroTask",Te="eventTask",B={},z={symbol:Se,currentZoneFrame:()=>x,onUnhandledError:ye,microtaskDrainDone:ye,scheduleMicroTask:_e,showUncaughtError:()=>!s[Se("ignoreConsoleErrorUncaughtError")],patchEventTarget:()=>[],patchOnProperties:ye,patchMethod:()=>ye,bindArguments:()=>[],patchThen:()=>ye,patchMacroTask:()=>ye,patchEventPrototype:()=>ye,isIEOrEdge:()=>!1,getGlobalObjects:()=>{},ObjectDefineProperty:()=>ye,ObjectGetOwnPropertyDescriptor:()=>{},ObjectCreate:()=>{},ArraySlice:()=>[],patchClass:()=>ye,wrapWithCurrentZone:()=>ye,filterProperties:()=>[],attachOriginToPatched:()=>ye,_redefineProperty:()=>ye,patchCallbacks:()=>ye,nativeScheduleMicroTask:ae};let x={parent:null,zone:new s(null,null)},Q=null,Ie=0;function ye(){}return f("Zone","Zone"),s}(),t.Zone}();(function jt(t){(function Dt(t){t.__load_patch("ZoneAwarePromise",(o,f,s)=>{const l=Object.getOwnPropertyDescriptor,T=Object.defineProperty,O=s.symbol,j=[],G=!1!==o[O("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")],A=O("Promise"),q=O("then"),ee="__creationTrace__";s.onUnhandledError=p=>{if(s.showUncaughtError()){const d=p&&p.rejection;d?console.error("Unhandled Promise rejection:",d instanceof Error?d.message:d,"; Zone:",p.zone.name,"; Task:",p.task&&p.task.source,"; Value:",d,d instanceof Error?d.stack:void 0):console.error(p)}},s.microtaskDrainDone=()=>{for(;j.length;){const p=j.shift();try{p.zone.runGuarded(()=>{throw p.throwOriginal?p.rejection:p})}catch(d){_e(d)}}};const ae=O("unhandledPromiseRejectionHandler");function _e(p){s.onUnhandledError(p);try{const d=f[ae];"function"==typeof d&&d.call(this,p)}catch{}}function Ce(p){return p&&p.then}function Re(p){return p}function be(p){return ne.reject(p)}const L=O("state"),w=O("value"),oe=O("finally"),ue=O("parentPromiseValue"),Pe=O("parentPromiseState"),he="Promise.then",M=null,Te=!0,B=!1,z=0;function x(p,d){return u=>{try{X(p,d,u)}catch(_){X(p,!1,_)}}}const Q=function(){let p=!1;return function(u){return function(){p||(p=!0,u.apply(null,arguments))}}},Ie="Promise resolved with itself",ye=O("currentTaskTrace");function X(p,d,u){const _=Q();if(p===u)throw new TypeError(Ie);if(p[L]===M){let N=null;try{("object"==typeof u||"function"==typeof u)&&(N=u&&u.then)}catch(W){return _(()=>{X(p,!1,W)})(),p}if(d!==B&&u instanceof ne&&u.hasOwnProperty(L)&&u.hasOwnProperty(w)&&u[L]!==M)i(u),X(p,u[L],u[w]);else if(d!==B&&"function"==typeof N)try{N.call(u,_(x(p,d)),_(x(p,!1)))}catch(W){_(()=>{X(p,!1,W)})()}else{p[L]=d;const W=p[w];if(p[w]=u,p[oe]===oe&&d===Te&&(p[L]=p[Pe],p[w]=p[ue]),d===B&&u instanceof Error){const F=f.currentTask&&f.currentTask.data&&f.currentTask.data[ee];F&&T(u,ye,{configurable:!0,enumerable:!1,writable:!0,value:F})}for(let F=0;F<W.length;)a(p,W[F++],W[F++],W[F++],W[F++]);if(0==W.length&&d==B){p[L]=z;let F=u;try{throw new Error("Uncaught (in promise): "+function D(p){return p&&p.toString===Object.prototype.toString?(p.constructor&&p.constructor.name||"")+": "+JSON.stringify(p):p?p.toString():Object.prototype.toString.call(p)}(u)+(u&&u.stack?"\n"+u.stack:""))}catch($){F=$}G&&(F.throwOriginal=!0),F.rejection=u,F.promise=p,F.zone=f.current,F.task=f.currentTask,j.push(F),s.scheduleMicroTask()}}}return p}const I=O("rejectionHandledHandler");function i(p){if(p[L]===z){try{const d=f[I];d&&"function"==typeof d&&d.call(this,{rejection:p[w],promise:p})}catch{}p[L]=B;for(let d=0;d<j.length;d++)p===j[d].promise&&j.splice(d,1)}}function a(p,d,u,_,N){i(p);const W=p[L],F=W?"function"==typeof _?_:Re:"function"==typeof N?N:be;d.scheduleMicroTask(he,()=>{try{const $=p[w],K=!!u&&oe===u[oe];K&&(u[ue]=$,u[Pe]=W);const Y=d.run(F,void 0,K&&F!==be&&F!==Re?[]:[$]);X(u,!0,Y)}catch($){X(u,!1,$)}},u)}const U=function(){},ke=o.AggregateError;class ne{static toString(){return"function ZoneAwarePromise() { [native code] }"}static resolve(d){return d instanceof ne?d:X(new this(null),Te,d)}static reject(d){return X(new this(null),B,d)}static withResolvers(){const d={};return d.promise=new ne((u,_)=>{d.resolve=u,d.reject=_}),d}static any(d){if(!d||"function"!=typeof d[Symbol.iterator])return Promise.reject(new ke([],"All promises were rejected"));const u=[];let _=0;try{for(let F of d)_++,u.push(ne.resolve(F))}catch{return Promise.reject(new ke([],"All promises were rejected"))}if(0===_)return Promise.reject(new ke([],"All promises were rejected"));let N=!1;const W=[];return new ne((F,$)=>{for(let K=0;K<u.length;K++)u[K].then(Y=>{N||(N=!0,F(Y))},Y=>{W.push(Y),_--,0===_&&(N=!0,$(new ke(W,"All promises were rejected")))})})}static race(d){let u,_,N=new this(($,K)=>{u=$,_=K});function W($){u($)}function F($){_($)}for(let $ of d)Ce($)||($=this.resolve($)),$.then(W,F);return N}static all(d){return ne.allWithCallback(d)}static allSettled(d){return(this&&this.prototype instanceof ne?this:ne).allWithCallback(d,{thenCallback:_=>({status:"fulfilled",value:_}),errorCallback:_=>({status:"rejected",reason:_})})}static allWithCallback(d,u){let _,N,W=new this((Y,fe)=>{_=Y,N=fe}),F=2,$=0;const K=[];for(let Y of d){Ce(Y)||(Y=this.resolve(Y));const fe=$;try{Y.then(de=>{K[fe]=u?u.thenCallback(de):de,F--,0===F&&_(K)},de=>{u?(K[fe]=u.errorCallback(de),F--,0===F&&_(K)):N(de)})}catch(de){N(de)}F++,$++}return F-=2,0===F&&_(K),W}constructor(d){const u=this;if(!(u instanceof ne))throw new Error("Must be an instanceof Promise.");u[L]=M,u[w]=[];try{const _=Q();d&&d(_(x(u,Te)),_(x(u,B)))}catch(_){X(u,!1,_)}}get[Symbol.toStringTag](){return"Promise"}get[Symbol.species](){return ne}then(d,u){let _=this.constructor?.[Symbol.species];(!_||"function"!=typeof _)&&(_=this.constructor||ne);const N=new _(U),W=f.current;return this[L]==M?this[w].push(W,N,d,u):a(this,W,N,d,u),N}catch(d){return this.then(null,d)}finally(d){let u=this.constructor?.[Symbol.species];(!u||"function"!=typeof u)&&(u=ne);const _=new u(U);_[oe]=oe;const N=f.current;return this[L]==M?this[w].push(N,_,d,d):a(this,N,_,d,d),_}}ne.resolve=ne.resolve,ne.reject=ne.reject,ne.race=ne.race,ne.all=ne.all;const Be=o[A]=o.Promise;o.Promise=ne;const ze=O("thenPatched");function We(p){const d=p.prototype,u=l(d,"then");if(u&&(!1===u.writable||!u.configurable))return;const _=d.then;d[q]=_,p.prototype.then=function(N,W){return new ne(($,K)=>{_.call(this,$,K)}).then(N,W)},p[ze]=!0}return s.patchThen=We,Be&&(We(Be),E(o,"fetch",p=>function Fe(p){return function(d,u){let _=p.apply(d,u);if(_ instanceof ne)return _;let N=_.constructor;return N[ze]||We(N),_}}(p))),Promise[f.__symbol__("uncaughtPromiseErrors")]=j,ne})})(t),function Ot(t){t.__load_patch("toString",o=>{const f=Function.prototype.toString,s=re("OriginalDelegate"),l=re("Promise"),T=re("Error"),D=function(){if("function"==typeof this){const A=this[s];if(A)return"function"==typeof A?f.call(A):Object.prototype.toString.call(A);if(this===Promise){const q=o[l];if(q)return f.call(q)}if(this===Error){const q=o[T];if(q)return f.call(q)}}return f.call(this)};D[s]=f,Function.prototype.toString=D;const O=Object.prototype.toString;Object.prototype.toString=function(){return"function"==typeof Promise&&this instanceof Promise?"[object Promise]":O.call(this)}})}(t),function Ft(t){t.__load_patch("util",(o,f,s)=>{const l=Tt(o);s.patchOnProperties=c,s.patchMethod=E,s.bindArguments=et,s.patchMacroTask=R;const T=f.__symbol__("BLACK_LISTED_EVENTS"),D=f.__symbol__("UNPATCHED_EVENTS");o[D]&&(o[T]=o[D]),o[T]&&(f[T]=f[D]=o[T]),s.patchEventPrototype=me,s.patchEventTarget=k,s.isIEOrEdge=ie,s.ObjectDefineProperty=Je,s.ObjectGetOwnPropertyDescriptor=xe,s.ObjectCreate=ft,s.ArraySlice=ce,s.patchClass=P,s.wrapWithCurrentZone=Ke,s.filterProperties=yt,s.attachOriginToPatched=g,s._redefineProperty=Object.defineProperty,s.patchCallbacks=Mt,s.getGlobalObjects=()=>({globalSources:b,zoneSymbolEventNames:m,eventNames:l,isBrowser:ct,isMix:lt,isNode:tt,TRUE_STR:Ae,FALSE_STR:le,ZONE_SYMBOL_PREFIX:pe,ADD_EVENT_LISTENER_STR:Oe,REMOVE_EVENT_LISTENER_STR:Me})})}(t)})(gt),function It(t){t.__load_patch("legacy",o=>{const f=o[t.__symbol__("legacyPatch")];f&&f()}),t.__load_patch("timers",o=>{const f="set",s="clear";rt(o,f,s,"Timeout"),rt(o,f,s,"Interval"),rt(o,f,s,"Immediate")}),t.__load_patch("requestAnimationFrame",o=>{rt(o,"request","cancel","AnimationFrame"),rt(o,"mozRequest","mozCancel","AnimationFrame"),rt(o,"webkitRequest","webkitCancel","AnimationFrame")}),t.__load_patch("blocking",(o,f)=>{const s=["alert","prompt","confirm"];for(let l=0;l<s.length;l++)E(o,s[l],(D,O,j)=>function(G,A){return f.current.run(D,o,A,j)})}),t.__load_patch("EventTarget",(o,f,s)=>{(function Rt(t,o){o.patchEventPrototype(t,o)})(o,s),function Ct(t,o){if(Zone[o.symbol("patchEventTarget")])return;const{eventNames:f,zoneSymbolEventNames:s,TRUE_STR:l,FALSE_STR:T,ZONE_SYMBOL_PREFIX:D}=o.getGlobalObjects();for(let j=0;j<f.length;j++){const G=f[j],ee=D+(G+T),ae=D+(G+l);s[G]={},s[G][T]=ee,s[G][l]=ae}const O=t.EventTarget;O&&O.prototype&&o.patchEventTarget(t,o,[O&&O.prototype])}(o,s);const l=o.XMLHttpRequestEventTarget;l&&l.prototype&&s.patchEventTarget(o,s,[l.prototype])}),t.__load_patch("MutationObserver",(o,f,s)=>{P("MutationObserver"),P("WebKitMutationObserver")}),t.__load_patch("IntersectionObserver",(o,f,s)=>{P("IntersectionObserver")}),t.__load_patch("FileReader",(o,f,s)=>{P("FileReader")}),t.__load_patch("on_property",(o,f,s)=>{!function At(t,o){if(tt&&!lt||Zone[t.symbol("patchEvents")])return;const f=o.__Zone_ignore_on_properties;let s=[];if(ct){const l=window;s=s.concat(["Document","SVGElement","Element","HTMLElement","HTMLBodyElement","HTMLMediaElement","HTMLFrameSetElement","HTMLFrameElement","HTMLIFrameElement","HTMLMarqueeElement","Worker"]);const T=function ve(){try{const t=Ve.navigator.userAgent;if(-1!==t.indexOf("MSIE ")||-1!==t.indexOf("Trident/"))return!0}catch{}return!1}()?[{target:l,ignoreProperties:["error"]}]:[];kt(l,Tt(l),f&&f.concat(T),Ge(l))}s=s.concat(["XMLHttpRequest","XMLHttpRequestEventTarget","IDBIndex","IDBRequest","IDBOpenDBRequest","IDBDatabase","IDBTransaction","IDBCursor","WebSocket"]);for(let l=0;l<s.length;l++){const T=o[s[l]];T&&T.prototype&&kt(T.prototype,Tt(T.prototype),f)}}(s,o)}),t.__load_patch("customElements",(o,f,s)=>{!function wt(t,o){const{isBrowser:f,isMix:s}=o.getGlobalObjects();(f||s)&&t.customElements&&"customElements"in t&&o.patchCallbacks(o,t.customElements,"customElements","define",["connectedCallback","disconnectedCallback","adoptedCallback","attributeChangedCallback","formAssociatedCallback","formDisabledCallback","formResetCallback","formStateRestoreCallback"])}(o,s)}),t.__load_patch("XHR",(o,f)=>{!function G(A){const q=A.XMLHttpRequest;if(!q)return;const ee=q.prototype;let _e=ee[De],Ce=ee[ot];if(!_e){const z=A.XMLHttpRequestEventTarget;if(z){const x=z.prototype;_e=x[De],Ce=x[ot]}}const Re="readystatechange",be="scheduled";function L(z){const x=z.data,Q=x.target;Q[D]=!1,Q[j]=!1;const Ie=Q[T];_e||(_e=Q[De],Ce=Q[ot]),Ie&&Ce.call(Q,Re,Ie);const ye=Q[T]=()=>{if(Q.readyState===Q.DONE)if(!x.aborted&&Q[D]&&z.state===be){const I=Q[f.__symbol__("loadfalse")];if(0!==Q.status&&I&&I.length>0){const i=z.invoke;z.invoke=function(){const a=Q[f.__symbol__("loadfalse")];for(let Z=0;Z<a.length;Z++)a[Z]===z&&a.splice(Z,1);!x.aborted&&z.state===be&&i.call(z)},I.push(z)}else z.invoke()}else!x.aborted&&!1===Q[D]&&(Q[j]=!0)};return _e.call(Q,Re,ye),Q[s]||(Q[s]=z),Te.apply(Q,x.args),Q[D]=!0,z}function w(){}function oe(z){const x=z.data;return x.aborted=!0,B.apply(x.target,x.args)}const ue=E(ee,"open",()=>function(z,x){return z[l]=0==x[2],z[O]=x[1],ue.apply(z,x)}),he=re("fetchTaskAborting"),M=re("fetchTaskScheduling"),Te=E(ee,"send",()=>function(z,x){if(!0===f.current[M]||z[l])return Te.apply(z,x);{const Q={target:z,url:z[O],isPeriodic:!1,args:x,aborted:!1},Ie=Ye("XMLHttpRequest.send",w,Q,L,oe);z&&!0===z[j]&&!Q.aborted&&Ie.state===be&&Ie.invoke()}}),B=E(ee,"abort",()=>function(z,x){const Q=function ae(z){return z[s]}(z);if(Q&&"string"==typeof Q.type){if(null==Q.cancelFn||Q.data&&Q.data.aborted)return;Q.zone.cancelTask(Q)}else if(!0===f.current[he])return B.apply(z,x)})}(o);const s=re("xhrTask"),l=re("xhrSync"),T=re("xhrListener"),D=re("xhrScheduled"),O=re("xhrURL"),j=re("xhrErrorBeforeScheduled")}),t.__load_patch("geolocation",o=>{o.navigator&&o.navigator.geolocation&&function _t(t,o){const f=t.constructor.name;for(let s=0;s<o.length;s++){const l=o[s],T=t[l];if(T){if(!ut(xe(t,l)))continue;t[l]=(O=>{const j=function(){return O.apply(this,et(arguments,f+"."+l))};return g(j,O),j})(T)}}}(o.navigator.geolocation,["getCurrentPosition","watchPosition"])}),t.__load_patch("PromiseRejectionEvent",(o,f)=>{function s(l){return function(T){J(o,l).forEach(O=>{const j=o.PromiseRejectionEvent;if(j){const G=new j(l,{promise:T.promise,reason:T.rejection});O.invoke(G)}})}}o.PromiseRejectionEvent&&(f[re("unhandledPromiseRejectionHandler")]=s("unhandledrejection"),f[re("rejectionHandledHandler")]=s("rejectionhandled"))}),t.__load_patch("queueMicrotask",(o,f,s)=>{!function Qe(t,o){o.patchMethod(t,"queueMicrotask",f=>function(s,l){Zone.current.scheduleMicroTask("queueMicrotask",l[0])})}(o,s)})}(gt)}},we=>{we(we.s=50)}]);